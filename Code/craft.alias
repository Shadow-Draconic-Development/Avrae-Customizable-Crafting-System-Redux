embed
<drac2>


def set_default_settings(dictionary: dict, default_dictionary: dict) -> dict:
    """
    Loops through dictionary checking for missing entries and adding default ones where necessary

    Args:
        dictionary (dict): Dictionary to be checked
        default_dictionary (dict): Default dictionary

    Return:
        dict: Corrected dictionary
    """

    # For each key in the default dictionary
    for default_key in default_dictionary.keys():

        # If the value is not a dictionary
        if typeof(default_dictionary[default_key]) != "SafeDict":

            if default_key in dictionary.keys():
                pass

            else:
                dictionary[default_key] = default_dictionary[default_key]

        # If the value is a dictionary
        else:

            # Check to see if it is a threshold dictionary
            try:
                for test_key in default_dictionary[default_key].keys():
                    float(test_key)

                if default_key in dictionary.keys():
                    pass

                else:
                    dictionary[default_key] = default_dictionary[default_key]

            # If it is not a threshold dictionary, run recursive call to check values of inner dictionary
            except:
                dictionary[default_key] = set_default_settings(dictionary[default_key], default_dictionary[default_key]) 

    return dictionary


def check_channel(svar_dict: dict) -> bool:
    """
    Checks channel to see if it is a valid channel to craft in

    Args:
        svar_dict (dict): Server settings

    Return:
        bool: Status of valid channel
    """

    # If there are no channels listed
    if len(channel_list := svar_dict["whitelisted_channel_ids"]) == 0:
        return True

    # If there is at least one channel listed
    else:

        # If channel is in whitelist
        if ctx.channel.id in channel_list:
            return True

        # If channel is not in whitelist
        else:

            # If channel is actually a thread and parent to child inheritance is turned on
            if (parent_obj := ctx.channel.parent) and svar_test["parent_channel_inherit"]:

                # If parent channel is in whitelist
                if parent_obj.id in channel_list:
                    return True

                # If parent channel is not in whitelist
                else:
                    return False

            # If channel is not a thread or parent to child inheritance is turned off
            else:
                return False

def search_list(query: str, item_list: list[str]) -> list[str]|None:
    """
    Searches for item in list.

    Args:
        query (str): The query being made
        item_list (list): List of items

    Return:
        list[str]|None: If it finds at least one match, it returns the item(s) in a list, otherwise it returns None
    """

    # Finds at least 1 match
    if len(item_results := [item for item in item_list if query.lower() in item.lower()]) > 0:
        return item_results

    # If it finds no matches
    else:
        return None


def parse_convert_money(money_input: str|float) -> float|None:
    """
    Converts money from standard currency to gold

    Args:
        money_input (str|float): String/float value of money

    Return:
        float|None: Gold amount, None object if unable to parse
    """

    # Try to turn it into a float
    try:
        return round(float(money_input), 2)

    # If it is a string amount
    except:

        match money_input[-2:].lower():

            # Platinum
            case "pp":
                return round(float(money_input[-2:]) * 10, 2)

            # Gold
            case "gp":
                return round(float(money_input[-2:]), 2)

            # Electrum
            case "ep":
                return round(float(money_input[-2:]) / 2, 2)

            # Silver
            case "sp":
                return round(float(money_input[-2:]) / 10, 2)

            # Copper
            case "cp":
                return round(float(money_input[-2:]) / 100, 2)

            # No-matching items
            case _:
                return None


def grab_crafting_details(craft_category: str, craft_type: str, svar_dict: dict) -> tuple(str|None, str, str):
    """
    Grabs the crafting details from server settings

    Args:
        craft_category (str): Crafting category to be searched
        craft_type (str): Crafting type to be searched
        svar_dict (dict): Crafting dictionary

    Return:
        str|None: Crafting category name, None if error
        str: Crafting type name
        str: Crafting type (cost or "")
    """

    # Set default behavior
    type_dict = False
    
    # If there is at least one match (item category)
    if (search_result := search_list(craft_category), svar_dict.keys()):

        # If there is exactly one match
        if len(search_result) == 1:

            # Store category name and type dictionary
            craft_category = search_result[0]
            type_dict = svar_dict[craft_category]

        # If there are more than one match
        else:

            # For each match
            for match in search_result:

                # If match is not exactly matching
                if match.lower() != craft_category.lower():
                    pass

                # If match is exactly matching, store category name and type dictionary
                else:
                    craft_category = match
                    type_dict = svar_dict[match]

            # If type dictionary was grabbed
            if type_dict:
                pass

            # If type dictionary was not found
            else:

                search_result.insert(0, "**Multiple Categories Found:**")

                return None, "\n".join(search_result), ""

    # If there were no matches
    else:
        return None, f"Crafting category does not exist (`{craft_category}`)", ""

    # Set default behavior
    coin_based = False

    # Try to turn each key into a number
    try:
        for _type in type_dict.keys():
            float(_type)

        # Set to cost based if no errors
        coin_based = True

    except:
        pass

    # If craft settings is not cost based
    if not coin_based:

        # If it finds at least one type
        if (search_result := search_list(craft_type, type_dict.keys())):

            # If there is at least one match
            if len(search_result) == 1:
                return craft_category, search_result[0], ""

            # 
            else:

                for match in search_result:
                    if match.lower() != craft_type.lower():
                        pass

                    else:
                        return craft_category, match, ""

                search_result.insert(0, "**Multiple Types Found:**")

                return None, "\n".join(search_result)

        else:
            return None, f"Type category within {craft_category} does not exist (`{craft_type}`)", ""


    else:

        if (craft_type := parse_convert_money(craft_type)):

            craft_ready = False

            type_list = list(type_dict.keys())
            type_list.sort()

            for _type in type_list:
                
                if craft_type >= float(_type):
                    craft_ready = _type

                else:
                    if craft_ready:
                        return craft_category, craft_type, craft_ready

                    else:
                        return None, "No thresholds were met on item cost", ""
                
        else:
            return None, "Error parsing monetary input", ""
                        

def run_crafting_session(cvar_dict: dict, svar_dict: dict, ch: AliasCharacter, success_cc: AliasCustomCounter, failure_cc: AliasCustomCounter, money_delta_dict: dict = {}, money_dict: dict = {}, arg_adv: int = 0, arg_bonus: list[str] = [], arg_i: bool = False, arg_stat: str = ""):

    def lucky_reroll(rerolled: bool) -> list[bool, SimpleRollResult]:
        """
        Handles halfling_lucky rerolls
        
        Args:
            rerolled (bool): Whether or not if lucky had already been triggered
        
        Return:
            (list[bool, SimpleRollResult]): Results
        """
        dice_roll = vroll('1d20')

        if not rerolled:
            if dice_roll.total != 1:
                return [False, dice_roll]

            else:
                return [True, vroll('1d20'), "**~~1~~**"]

        else:
            return [True, dice_roll]

    skill_list = ["acrobatics", "animalHandling", "arcana", "athletics", "deception", "history", "insight", "intimidation", "investigation", "medicine", "nature", "perception", "performance", "persuasion", "religion", "sleightOfHand", "stealth", "survival", 'strength', 'dexterity', 'constitution', 'intellegence', 'wisdom', 'charisma']

    if (search_result := search_list(arg_stat, skill_list)):

        if len(search_result) == 1:
            cvar_dict['stat'] = search_result[0]

        else:
            cvar_dict['stat'] = ""

    else:
        cvar_dict['stat'] = ""

    bonus_str_list = []

    for bonus in arg_bonus:

        if "d" in bonus.lower():
            bonus_str_list.append(bonus)

        else:
            try:
                bonus_str_list.append(float(bonus))

            except:
                pass

    if len(bonus_str_list) == 0:
        bonus_str = ""

    else:
        bonus_str = "+" + "+".join(bonus_str_list)

    if cvar_dict['stat'] != "":
        skill_obj = ch.skills[cvar_dict['stat']]

        prof_type, skill_val = skill_obj.prof, skill_obj.value

    else:
        prof_type, skill_val = 0, 0

    if not svar_dict['jack_of_trades'] and prof_type == 0.5:
        skill_val -= int(proficiencyBonus / 2)

    else:
        pass

    if svar_dict['reliable_talent'] and ch.levels.get("rogue") > 10 and prof_type > 0:
        min_str = "mi10"

    else:
        min_str = ""

    if "halfling" in str(ch.race).lower():
        reroll_str = "ro1"

    else:
        reroll_str = ""

    match arg_adv:

        case 1:
            part_dice_str = "2d20kh1"

        case 2:
            part_dice_str = "3d20kh1"

        case -1:
            part_dice_str = "2d20kl1"

        case _:
            part_dice_str = "d20"

    roll_obj = vroll(f"{part_dice_str}{reroll_str}{min_str}+{skill_val}{bonus_str}")

    if (roll_diff := roll_obj.total - cvar_dict['dc']) >= 0:
        failure_mod = 0
        success_mod = 1
        success = True

        try:
            for threshold, value in svar_dict["success_mod_threshold"]:
                if roll_diff >= int(threshold):
                    success_mod = int(value)

                else:
                    break

        except:
            pass

    else:
        failure_mod = 1
        success_mod = 0
        success = False


    if (crit_val := int(roll_obj.result.crit)) in [1,2]:

        if crit_val == 2:
            success_mod -= abs(cvar_dict['nat1'])

        else:
            success_mod += abs(cvar_dict['nat20'])

            if success_mod > (succ_max := max(svar_dict["success_mod_threshold"].values())):
                success_mod = succ_max

            else:
                pass

    else:
        pass

    success_value = success_cc.mod(success_mod)
    failure_value = failure_cc.mod(failure_mod)

    ch.set_cvar("crafting_dict", dump_json(cvar_dict))

    result_string = []

    if success:
        result_string.append("**Success**")

    else:
        result_string.append("**Failure**")

    if cvar_dict["stat"] != "":

        if cvar_dict["stat"] == "sleightOfHand":
            skill_name = "Sleight of Hand"

        elif cvar_dict["stat"] == "animalHandling":
            skill_name = "Animal Handling"

        else:
            skill_name = cvar_dict["stat"].capitalize()

        result_string.append(f"Skill Used: {skill_name}")

    else:
        result_string.append("Skill Used: None")

    result_string.append(f"DC: {cvar_dict['dc']}\n")

    result_string.append(roll_obj.full + "\n")

    if success_mod > 0:
        result_string.append(f"Successes: {success_value}/{success_cc.max} (+{success_mod})")

    elif success_mod < 0:
        result_string.append(f"Successes: {success_value}/{success_cc.max} ({success_mod})")

    else:
        result_string.append(f"Successes: {success_value}/{success_cc.max}")

    if f"{success_cc.value}/{success_cc.max}" == (succ_str := success_cc.full_str().split("\n")[0]):
        pass

    else:
        result_string.append(succ_str)

    # Failure results
    if failure_mod > 0:
        result_string.append(f"Failures: {failure_value}/{failure_cc.max} (+{failure_mod})")

    elif failure_mod < 0:
        result_string.append(f"Failures: {failure_value}/{failure_cc.max} ({failure_mod})")

    else:
        result_string.append(f"Failures: {failure_value}/{failure_cc.max}")

    if f"{failure_cc.value}/{failure_cc.max}" == (fail_str := failure_cc.full_str().split("\n")[0]):
        pass

    else:
        result_string.append(fail_str)

    server_prefix = ctx.prefix

    # Checks to see if the failure counter is at max
    if failure_value == failure_cc.max:
        result_string.append("")
        result_string.append(f"Maximum failures reached for a {cvar_dict['name']}! Please run `{server_prefix}craft clear` as you have ruined your materials.")

    # Checks to see if the success counter is at max
    elif success_value == success_cc.max:
        result_string.append("")
        result_string.append(f"You have finished crafting a {cvar_dict['name']}! Please run `{server_prefix}craft clear` as you have finished your item.")

    else:
        pass

    if cvar_dict['bypass']:
        result_string.append("\n`BYPASS USED`")

    else:
        pass

    result_string.append(f"Next Crafting Session: <t:{cvar_dict['time'] + cvar_dict['cooldown']}:f>")
    
    if money_delta_dict != {}:

        money_delta_float = money_delta_dict.pop("total")

        if money_delta_float % 1 == 0:
            money_delta_float = int(money_delta_float)

        else:
            pass

        coin_emoji_mapping = {
            "cp": "<:DDBCopper:953399505129205830>",
            "sp": "<:DDBSilver:953399505124995122>",
            "ep": "<:DDBElectrum:953399505129205831>",
            "gp": "<:DDBGold:953399505062080594>",
            "pp": "<:DDBPlatinum:953399504739106847>"
        }

        money_str_list = [
            f"\n{coin_emoji_mapping[currency_shorthand]} {money_dict[currency_shorthand]} ({currency_value})"
            if currency_value != 0
            else f"{coin_emoji_mapping[currency_shorthand]} {money_dict[currency_shorthand]}"
            for currency_shorthand, currency_value in money_delta_dict.items()
        ]

        money_str_list.append(f"\n<:DDBGold:953399505062080594> {money_delta_float} removed")

        result_string.append("\n".join(money_str_list))

    else:
        pass

    if image != "":
        img_url = image

    else:
        img_url = "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/main.png"

    return f"{name}'s Crafting Session", "\n".join(result_string), img_url, cvar_dict["color"]


def withdraw_funds(ch: AliasCharacter, gold_cost: float):
    
    def parse_gold_amount(amount: float) -> tuple(int, int, int):

        gold = int(amount)
        remaining_copper = round((amount - gold) * 100)
        silver = remaining_copper // 10
        copper = remaining_copper % 10

        return gold, silver, copper

    purse_obj = ch.coinpurse

    if (gold_cost := abs(gold_cost)) >= (purse_total := purse_obj.total):
        gold, silver, copper = parse_gold_amount(gold_cost)

        delta_dict = purse_obj.modify_coins(
            gp=gold * -1,
            sp=silver * -1,
            cp=copper * -1 
        )

        after_dict = purse_obj.get_coins()

        return delta_dict, after_dict, gold_cost

    else:
        gold, silver, copper = parse_gold_amount(purse_total - gold_cost)

        result_string = ""

        if gold > 0:
            result_string += f"{gold} gold,"

        else:
            pass

        if silver > 0:
            result_string += f" {silver} silver,"

        else:
            pass

        if copper > 0:
            result_string += f" {copper} copper"

        else:
            pass

        return None, f"{name} is {result_string.lstrip().rstrip(',')} short", ""


def run_new_craft(input_list: list[str], svar_dict: dict, ch: AliasCharacter):


    args = argparse(input_list)
    arg_adv = args.adv(eadv=True, boolwise=True)
    arg_bonus = args.get("b", default=[])
    arg_i = args.last("i", default=False)
    arg_stat = args.last("s", default="")
    arg_cost = args.last('c', default=1.0)
    arg_succ = args.last('succ', default=1.0)

    try:
        if (arg_cost := float(arg_cost)) < 0:
            arg_cost = 0.0

        else:
            pass

    except:
        arg_cost = 1.0

    try:
        if (arg_succ := float(arg_succ)) <= 0:
            arg_succ = 0.01

        else:
            pass

    except:
        arg_succ = 1.0


    output1, output2, output3 = grab_crafting_details(input_list[1], input_list[2], svar_dict)

    current_time = int(time())

    if output1:

        item_name = input_list[0].title()
        item_category = output1
        item_type = output2
        craft_cost = 0

    else:
        return "You Have Been Sneak Attacked by an Error", output2, "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    # [0"Level Requirement (int)", 1"DC (int)", 2"Nat1 Penalty (int)", 3"Nat20 Bonus (int)", 4"Total Successes (int)", 5"Total Failures Allowed (int)", 6"Cooldown In Seconds (int)", 7"Retail Item Cost in GP (int or float)", 8"Hex code (with or without #)"]

    if output3 == "":
        crafting_settings = svar_dict[item_category][item_type]

        if (craft_cost := parse_convert_money(crafting_settings[7])):
            craft_cost = craft_cost

        else:
            return "You Have Been Sneak Attacked by an Error", "Error grabbing item cost", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    else:
        (item_type, craft_cost) = (output3, item_type)
        crafting_settings = svar_dict[item_category][item_type]

    if (ch.levels.total_level >= crafting_settings[0]) or arg_i:
        pass

    else:
        return "You Have Been Sneak Attacked by an Error", f"{name} is not high enough of a level to craft this item\n(Required: {crafting_settings[0]})", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    if (cvar_test := ch.get_cvar('cvar_dict')):
        cvar_dict = load_json(cvar_test)

        if ((cooldown_time := cvar_dict["time"] + crafting_settings[6]) <= current_time) or arg_i:
            cvar_dict["time"] = cooldown_time

        else:
            return "You Have Been Sneak Attacked by an Error", f"{name} cannot have a crafting session until <t:{cooldown_time}:f>", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    else:
        cvar_dict = {}

    if not arg_i and arg_cost != 0:
        output1, output2, output3 = withdraw_funds(ch, round(craft_cost * arg_cost / 2))

        if (delta_dict := output1):
            purse_dict = output2
            craft_cost = output3

        else:
            return "You Have Been Sneak Attacked by an Error", output2, "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    else:
        delta_dict = {}
        purse_dict = {}
        craft_cost = 0


    if cvar_dict != {}:
        pass

    else:
        cvar_dict["history"] = []

    cvar_dict['name'] = item_name
    cvar_dict['category'] = item_category
    cvar_dict['type'] = item_type
    cvar_dict['time'] = current_time
    cvar_dict['history'].insert(0, item_name)
    cvar_dict['crafting_cost'] = craft_cost

    cvar_dict['succ_mult'] = arg_succ
    cvar_dict['stat'] = arg_stat
    cvar_dict['level'] = crafting_settings[0]
    cvar_dict['dc'] = crafting_settings[1]
    cvar_dict['nat1'] = crafting_settings[2]
    cvar_dict['nat20'] = crafting_settings[3]
    cvar_dict['total_succ'] = crafting_settings[4]
    cvar_dict['max_fail'] = crafting_settings[5]
    cvar_dict['cooldown'] = crafting_settings[6]
    cvar_dict['color'] = crafting_settings[-1]

    if arg_i:
        cvar_dict['bypass'] = True

    else:
        cvar_dict['bypass'] = False

    # Create success CC
    success_cc = ch.create_cc(
        name="Crafting: Successes", 
        minVal="0", 
        maxVal=str(ceil(crafting_settings[4] * cvar_dict['succ_mult'])), 
        reset="none", 
        dispType=settings_dictionary["success_dispType"], 
        title=f"{item_name}'s Successes", 
        desc=f"Success Tracker for {item_name}", 
        initial_value="0"
    )

    # Create failure CC
    failure_cc = ch.create_cc(
        name="Crafting: Failures", 
        minVal="0", 
        maxVal=str(crafting_settings[5]), 
        reset="none", 
        dispType=settings_dictionary["failure_dispType"], 
        title=f"{item_name}'s Failures", 
        desc=f"Failure Tracker for {item_name}", 
        initial_value="0"
    )

    return run_crafting_session(cvar_dict, ch, success_cc, failure_cc, money_delta_dict=delta_dict, money_dict=purse_dict, arg_adv=arg_adv, arg_bonus=arg_bonus, arg_i=arg_i, arg_stat=arg_stat)

def run_continue_craft(args: ParsedArguments, svar_dict: dict, cvar_dict: dict, ch: AliasCharacter, success_cc: AliasCustomCounter, failure_cc: AliasCustomCounter):

    # Write this assuming we know that we are continuing a item
    arg_adv = args.adv(eadv=True, boolwise=True)
    arg_bonus = args.get("b", default=[])
    arg_i = args.last("i", default=False)
    arg_succ = args.last("succ", default=None)
    arg_stat = args.last("s", default=cvar_dict["stat"])

    if cvar_dict["type"] in svar_dict[cvar_dict['category']].keys():
        crafting_settings = svar_dict[cvar_dict['category']][cvar_dict['type']]

    else:
        return "You Have Been Sneak Attacked by an Error", f"Type settings not found for {cvar_dict['type']}, speak to a staff member for assistance.", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"


    cvar_dict['level'] = crafting_settings[0]
    cvar_dict['dc'] = crafting_settings[1]
    cvar_dict['nat1'] = crafting_settings[2]
    cvar_dict['nat20'] = crafting_settings[3]
    cvar_dict['total_succ'] = crafting_settings[4]
    cvar_dict['max_fail'] = crafting_settings[5]
    cvar_dict['cooldown'] = crafting_settings[6]
    cvar_dict['color'] = crafting_settings[-1]

    if arg_succ:
        try:
            cvar_dict['succ_mult'] = float(arg_succ)

        except:
            pass

    else:
        pass


    item_name = cvar_dict['name']
    current_time = int(time())
    cvar_dict['first'] = False

    success_cc = ch.edit_cc(
        name=success_cc.name,
        maxVal=str(ceil(cvar_dict['succ_mult'] * cvar_dict['total_succ'])),
        dispType=svar_dict["success_dispType"]
    )

    failure_cc = ch.edit_cc(
        name=failure_cc.name, 
        maxVal=str(cvar_dict['max_fail']),
        dispType=svar_dict["failure_dispType"]
    )

    if success_cc.value == success_cc.max:
        return "You Have Been Sneak Attacked by an Error", f"You have already completed the item (Success)", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    elif failure_cc.value == failure_cc.max:
        return "You Have Been Sneak Attacked by an Error", f"You have already completed the item (Failure)", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    else:
        pass

    if arg_i:
        cvar_dict['bypass'] = True

    else:
        cvar_dict['bypass'] = False

    if ((cooldown_time := cvar_dict["time"] + cvar_dict['cooldown']) <= current_time) or arg_i:
        
        if not arg_i:
            cvar_dict["time"] = current_time

        else:
            pass

    else:
        return "You Have Been Sneak Attacked by an Error", f"{name} cannot have a crafting session until <t:{cooldown_time}:f>", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    if (ch.levels.total_level >= cvar_dict["level"]) or arg_i:
        pass

    else:
        return "You Have Been Sneak Attacked by an Error", f"{name} is not high enough of a level to craft this item. This is likely due to staff changing settings\n(Required: {cvar_dict['level']})", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    return run_crafting_session(cvar_dict, svar_dict, ch, success_cc, failure_cc, arg_adv=arg_adv, arg_bonus=arg_bonus, arg_i=arg_i, arg_stat=arg_stat)


def main(input_list: list[str]) -> tuple(str, str, str, str):
    """
    
    
    """

    svar_dict_default = {
        "lfg_integration": False,
        "pro_rate_refund": True,
        "success_dispType": "star",
        "failure_dispType": "hex",
        "jack_of_trades": True,
        "reliable_talent": False,
        "success_mod_threshold": {
            "-999": 1,
            "5": 2,
            "10": 3,
            "15": 4,
            "20": 5
            }, 
        "whitelisted_channel_ids": [], 
        "parent_channel_inherit": False, 
        "xp_categories": False, 
        "max_history": 15
    }

    crafting_nonmagical_defaults = {
        "nonmagical": 
            {
                "0": [5, 8, -1, 5, 1, 1, 7200, "#242528"],
                "101": [9, 13, -2, 5, 5, 2, 14400, "#242528"],
                "501": [13, 18, -3, 5, 8, 3, 21600, "#242528"],
                "5001": [17, 23, -4, 5, 13, 4, 28800, "#242528"],
                "50001": [20, 25, -5, 5, 20, 5, 36000, "#242528"]
        }
    }

    # If SVAR exists, load dictionary
    if (svar_test := get_svar('crafting_settings')):
        svar_dict = set_default_settings(load_json(svar_test), svar_dict_default)

        # If there is at least one item category
        if len(svar_dict) > 11:
            pass

        # If there are no item categories
        else:
            svar_dict.update(crafting_nonmagical_defaults)

    # If SVAR does not exist, create dictionary via unpacking
    else:
        svar_dict = {**svar_dict_default, **crafting_nonmagical_defaults}
        

    # If channel is a valid channel, load character object
    if check_channel(svar_dict):
        ch = character()

    # If channel is not a valid channel
    else:
        return "You Have Been Sneak Attacked by an Error", "This channel/thread has not been whitelisted for crafting. Speak to a staff member for more information.", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"
    
    if ch.cc_exists("Crafting: Successes") and ch.cc_exists("Crafting: Failures") and (cvar_test := ch.get_cvar("crafting_dict")):
        return run_continue_craft(argparse(input_list), svar_dict, load_json(cvar_test), ch, ch.cc("Crafting: Successes"), ch.cc("Crafting: Failures"))

    else:

        if len(input_list) > 2:
            return run_new_craft(input_list, svar_dict, ch)

        else:
            return "You Have Been Sneak Attacked by an Error", "Expected at least 3 arguments when starting a new item", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

title, f, thumb, color = main(&ARGS&)
l = "<"


</drac2>
-title "{{title}}"
-f "{{f}}"
-thumb "{{thumb}}"
-color "{{color}}"
-footer "{{ctx.prefix}}craft {{l}}item name> {{l}}item category> {{l}}item type/item cost> | 1/19/24 | ShadowsStride"