embed
<drac2>


def set_default_settings(dictionary: dict, default_dictionary: dict) -> dict:
    """
    Loops through dictionary checking for missing entries and adding default ones where necessary

    Args:
        dictionary (dict): Dictionary to be checked
        default_dictionary (dict): Default dictionary

    Return:
        dict: Corrected dictionary
    """

    # For each key in the default dictionary
    for default_key in default_dictionary.keys():

        # If the value is not a dictionary
        if typeof(default_dictionary[default_key]) != "SafeDict":

            if default_key in dictionary.keys():
                pass

            else:
                dictionary[default_key] = default_dictionary[default_key]

        # If the value is a dictionary
        else:

            # Check to see if it is a threshold dictionary
            try:
                for test_key in default_dictionary[default_key].keys():
                    float(test_key)

                if default_key in dictionary.keys():
                    pass

                else:
                    dictionary[default_key] = default_dictionary[default_key]

            # If it is not a threshold dictionary, run recursive call to check values of inner dictionary
            except:
                dictionary[default_key] = set_default_settings(dictionary[default_key], default_dictionary[default_key]) 

    return dictionary


def search_list(query: str, item_list: list[str]) -> list[str]|None:
    """
    Searches for item in list.

    Args:
        query (str): The query being made
        item_list (list): List of items

    Return:
        list[str]|None: If it finds at least one match, it returns the item(s) in a list, otherwise it returns None
    """

    # Finds at least 1 match
    if len(item_results := [item for item in item_list if query.lower() in item.lower()]) > 0:
        return item_results

    # If it finds no matches
    else:
        return None


def check_channel(svar_dict: dict) -> bool:
    if len(channel_list := svar_dict["whitelisted_channel_ids"]) == 0:
        return True

    else:
        if ctx.channel.id in channel_list:
            return True

        else:
            if (parent_obj := ctx.channel.parent):
                if svar_dict["parent_channel_inherit"] and parent_obj.id in channel_list:
                    return True

                else:
                    return False

            else:
                return False


def parse_gold_amount(amount: float) -> tuple(int, int, int):

    gold = int(amount)
    remaining_copper = round((amount - gold) * 100)
    silver = remaining_copper // 10
    copper = remaining_copper % 10

    return gold, silver, copper


def calculate_experience(ch: AliasCharacter, item_value: float, svar_dict: dict, item_category: str, item_type: str) -> str:

    def _add_experience(ch: AliasCharacter, xp_amount: float):
        
        using(
            xplib="bd5e6af1-55e9-4c5b-b814-8f9b447091e7"
        )

        xplib.modify_xp(int(abs(xp_amount)))

        return f"{xp_amount}xp has been awarded"

    match (svar_dict["xp_categories"], typeof(svar_dict["xp_categories"])):

        case None, _:
            return ""

        case False, _:
            return ""

        case _, "SafeDict":

            if (search_result := search_list(item_category, svar_dict['xp_categories'].keys())):

                if len(search_result) == 1:
                    cvar_dict['category'] = search_result[0]

                else:
                    found = False

                    for match in search_result:
                        if match.lower() != cvar_dict['category'].lower():
                            pass

                        else:
                            cvar_dict['category'] = match
                            found = True

                    if found:
                        pass

                    else:
                        return ""

            else:
                return ""


            if "all" in svar_dict["xp_categories"][cvar_dict["category"]]:
                return _add_experience(ch, item_value)

            else:
                if (search_result := search_list(item_type, list(svar_dict["xp_categories"][cvar_dict["category"]]))):

                    if len(search_result) == 1:
                        return _add_experience(ch, item_value)

                    else:

                        for match in search_result:

                            if match.lower() != item_type.lower():
                                pass

                            else:
                                return _add_experience(ch, item_value)

                        return ""

                else:
                    return ""

        case _, "bool":
            return _add_experience(ch, item_value)

        case _, _:
            if "all" in svar_dict["xp_categories"]:
                return _add_experience(ch, item_value)

            else:

                if (search_result := search_list(item_category, list(svar_dict["xp_categories"]))):

                    if len(search_result) == 1:
                        return _add_experience(ch, item_value)

                    else:

                        for match in search_result:
                            if match.lower() != item_category.lower():
                                pass

                            else:
                                return _add_experience(ch, item_value)

                        return ""

                else:
                    return ""


def main() -> tuple(str, str, str, str)

    ch = character()

    if ch.cc_exists('Crafting: Successes') and ch.cc_exists('Crafting: Failures'):

        svar_dict_default = {
            "lfg_integration": False,
            "pro_rate_refund": True,
            "success_dispType": "star",
            "failure_dispType": "hex",
            "jack_of_trades": True,
            "reliable_talent": False,
            "success_mod_threshold": {
                "-999": 1,
                "5": 2,
                "10": 3,
                "15": 4,
                "20": 5
                }, 
            "whitelisted_channel_ids": [], 
            "parent_channel_inherit": False, 
            "xp_categories": False, 
            "max_history": 15,
        }

        crafting_nonmagical_defaults = {
            "nonmagical": {"0": [5, 8, -1, 5, 1, 1, 7200, "#242528"]
                "101": [9, 13, -2, 5, 5, 2, 14400, "#242528"],
                "501": [13, 18, -3, 5, 8, 3, 21600, "#242528"],
                "5001": [17, 23, -4, 5, 13, 4, 28800, "#242528"],
                "50001": [20, 25, -5, 5, 20, 5, 36000, "#242528"]
            }
        }

        # If SVAR exists, load dictionary
        if (svar_test := get_svar('crafting_settings')):
            svar_dict = set_default_settings(load_json(svar_test), svar_dict_default)

            # If there is at least one item category
            if len(svar_dict) > 11:
                pass

            # If there are no item categories
            else:
                svar_dict.update(crafting_nonmagical_defaults)

        # If SVAR does not exist, create dictionary via unpacking
        else:
            svar_dict = {**svar_dict_default, **crafting_nonmagical_defaults}

        success_cc, failure_cc = ch.cc('Crafting: Successes'), ch.cc('Crafting: Failures')

        if (cvar_test := ch.get_cvar("crafting_dict")):
            cvar_dict = load_json(cvar_test)

        else:
            return "You Have Been Sneak Attacked by an Error", f"CVAR for {name} does not exist", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    else:
        return "You Have Been Sneak Attacked by an Error", "Crafting CCs do not exist", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/error.png", "#CF142B"

    if svar_dict["pro_rate_refund"] and success_cc.value != success_cc.max and failure_cc.value != failure_cc.max and cvar_dict["crafting_cost"] != 0:

        if (percentage_back := (1 - ((success_counter.value / success_counter.max) + (failure_counter.value /(failure_counter.max * 2)))) * .5) < 0:
            money_back = 0

        else:
            gold, silver, copper = round(percentage_back * cvar_dict["crafting_cost"], 2)
            money_back = gold + .1 * silver + .01 * copper

            purse_obj = ch.coinpurse

            delta_dict = purse_obj.modify_coins(
                gp=abs(gold),
                sp=abs(silver),
                cp=abs(copper)
            )

    else:
        money_back = 0

    cvar_dict ={
        "backup": {
            "cvar": {
                "name": cvar_dict["name"],
                "category": cvar_dict["category"],
                "type": cvar_dict["type"],
                "time": cvar_dict["time"],
                "cooldown": cvar_dict["cooldown"],
                "crafting_cost": cvar_dict["crafting_cost"]
                "stat": cvar_dict["stat"],
                "succ_mult": cvar_dict["succ_mult"],
                "level": cvar_dict["level"],
                "dc": cvar_dict["dc"],
                "nat1": cvar_dict["nat1"],
                "nat20": cvar_dict["nat20"],
                "total_succ": cvar_dict["total_succ"],
                "max_fail": cvar_dict["max_fail"],
                "color": cvar_dict["color"]
            },
            "success_cc": {
                "value": success_cc.value,
                "max": success_cc.max,
                "desc": success_cc.desc,
                "title": success_cc.title
            },
            "failure_cc": {
                "value": failure_cc.value,
                "max": failure_cc.max,
                "desc": failure_cc.desc,
                "title": failure_cc.title
            },
            "money_back": money_back
        }
    }


    ch.delete_cc("Crafting: Successes")
    ch.delete_cc("Crafting: Failures")

    ch.set_cvar("crafting_dict", dump_json(cvar_dict))


    if money_back > 0:

        coin_emoji_mapping = {
            "cp": "<:DDBCopper:953399505129205830>",
            "sp": "<:DDBSilver:953399505124995122>",
            "gp": "<:DDBGold:953399505062080594>"
        }


        money_str = ""

        if gold > 0:
            money_str += f"{coin_emoji_mapping["gp"]} {gold}\n"

        else:
            pass

        if silver > 0:
            money_str += f"{coin_emoji_mapping["sp"]} {silver}\n"

        else:
            pass

        if copper > 0:
            money_str += f"{coin_emoji_mapping["cp"]} {copper}"

        else:
            pass

        money_str.lstrip().rstrip(',')

        return f"{name} Cleared Their Crafting Progress For a {cvar_dict["backup"]["name"]}", f"**Prorated Refund:**\n{money_str}", "https://raw.githubusercontent.com/Shadow-Draconic-Development/Avrae-Customizable-Crafting-System/main/Data/images/coin_bag.png"

    else:

        if cvar_dict["success_cc"]["value"] == cvar_dict["success_cc"]["max"]:

            return f"{name} Cleared Their Crafting Progress For a {cvar_dict["backup"]["name"]}", calculate_experience(ch, cvar_dict["backup"]["crafting_cost"], svar_dict, cvar_dict["backup"]["category"], cvar_dict["backup"]["type"]), "https://raw.githubusercontent.com/SethHartman13/Avrae-Aliases-Snippets/master/Aliases/craft/images/hammer.png", cvar_dict["backup"]['color']

        elif cvar_dict["failure_cc"]["value"] == cvar_dict["failure_cc"]["max"]
            return f"{name} Cleared Their Crafting Progress For a {cvar_dict["backup"]["name"]}", "", "https://raw.githubusercontent.com/SethHartman13/Avrae-Aliases-Snippets/master/Aliases/craft/images/fail.png", cvar_dict["backup"]['color'] 

        else:
            return f"{name} Cleared Their Crafting Progress For a {cvar_dict["backup"]["name"]}", "", "https://raw.githubusercontent.com/SethHartman13/Avrae-Aliases-Snippets/master/Aliases/craft/images/partial.png", cvar_dict["backup"]['color'] 


title, f, thumb, color = main()


</drac2>
-title "{{title}}"
-f "{{color}}"
-thumb "{{thumb}}"
-color "{{color}}"
-footer "{{ctx.prefix}}craft clear | 12/21/23 | ShadowsStride"